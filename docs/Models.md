# Models

Models are clojure functions that do one of two things, either call a `.sql` file in `resources` with the `defq` macro or they call one of the five
functions generated by the `defm` function. You can generate model functions just like migrations.

## `coast gen model posts`

This requires that the posts table already exists and it creates two files that work together to make your life easier, `src/db/posts.clj` and `src/models/posts.clj`.

Here's what the `db/posts.clj` file looks like

```clojure
(ns db.posts
  (:require [coast.epsilon :refer [defm]])
  (:refer-clojure :exclude [update find]))

(defm "posts")
```

## `defm`

`defm` is a function that generates a few sql helper functions in the current namespace:

- `find`
- `find-by`
- `find-or-create-by`
- `insert`
- `update`
- `delete`
- `query`

Here's an example of how each function created by `defm` can be used

## `find`

```clojure
(db.posts/find 1)
; (-> ["select * from posts where id = ? limit 1" 1] first)
```

## `find-by`

```clojure
(db.posts/find-by {:category "fun" :tag-count 0})
; (-> ["select * from posts where category = ? and tag_count = ?" "fun" 0] first)
```

## `find-or-create-by`

```clojure
(db.posts/find-or-create-by {:category "fun" :tag-count 0})
; (-> ["select * from posts where category = ? and tag_count = ?" "fun" 0] first)
; or
; ["insert into posts (category, tag_count) values (?, ?) returning *" "fun" 0]
```

## `insert`

```clojure
(db.posts/insert {:title "title" :body "body"})
; => ["insert into posts (title, body) values (?, ?) returning *" "title" "body"]
```

## `update`

```clojure
(db.posts/update {:id 1 :title "new title"})
; => ["update posts set title = ? where id = ? returning *" "new title" 1]

(db.posts/update {:title "newest title"} ["title = ?" "new title"])
; => ["update posts set title = ? where title = ? returning *" "newest title" "new title"]
```

## `delete`

```clojure
(db.posts/delete {:id 1})
; => ["delete from posts where id = ? returning *" 1]

(db.posts/delete ["title = ?" "new title"])
; => ["delete from posts where title = ? returning *" "new title"]
```

## `query`

```clojure
(db.posts/query {:where {:title "newest title"}
                 :order [:created-at :desc]})
; => ["select * from posts where title = ? order by created_at desc" "newest title"]

(db.posts/query)
; => ["select * from posts"]

(db.posts/query {:order [:created-at :desc]})
; => ["select * from posts order by created_at desc"]

(db.posts/query {:select [:title]})
; => ["select posts.title from posts"]

(db.posts/query {:select [:id :title :published-at :created-at]
                 :where {:published-at nil}
                 :order [:created-at :desc]})
; ["select posts.id, posts.title, posts.published_at, posts.created_at
;   from posts
;   where posts.published_at is null
;   order by created_at desc"]
```

So those cover basic sql things that you really don't want to have to type out *every* time. For more complex sql things,
why not just use the real deal? I'm talking about SQL. I'm a firm believer in having an escape hatch when an abstraction gets too leaky, thank goodness there's `defq`.

## `defq`

`defq` is a macro that reads a sql file located in `resources` at compile time and generates functions
with the symbols of the names in the sql file. If you try to specify a name that doesn't have a corresponding `-- name:`
in the sql resource, you'll get a compile exception, so that's kind of cool.

You can create any number of .sql files you want, so if you needed to customize
posts and join with comment counts or something similar, you could do this in `posts.sql`

```sql
-- name: posts-with-count
select
  posts.*,
  c.comment_count
from
  posts
join
  (
    select
      comments.post_id,
      count(comments.id) as comment_count
    from
      comments
    where
      comments.post_id = :post_id
    group by
      comments.post_id
 ) c on c.post_id = posts.id
 ```

 Then in the db file:

```clojure
(defq posts-with-count "sql/posts.sql")

(posts-with-count {:post-id 1}) ; => [{:id 1 ... :comment-count 12}]
```

And now you have a new function wired to a bit of custom sql.

The last part of the this process is the model file in a different namespace so the function names can be reused and called from the controllers:

```clojure
(ns models.posts
  (:require [db.posts]
            [coast.models])
  (:refer-clojure :exclude [find update]))

(defn validate [m]
  (let [validations []]
    (if (empty? validations)
      m
      (coast.models/validate validations m))))


(defn all []
  (db.posts/query))

(defn find [id]
  (db.posts/find id))

(defn create [m]
  (-> (validate m)
      (db.posts/insert)))

(defn update [m]
  (-> (validate m)
      (db.posts/update)))

(defn delete [m]
  (db.posts/delete))
```

Of course you don't even have to use these functions until you need them, it's perfectly ok to just call functions from the `db` namespace
and then insert validation and custom business logic in the model file when you need it.
